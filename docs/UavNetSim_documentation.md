# UavNetSim Code Documentation

Generated by tools/generate_repo_doc.py

## File: allocation\central_controller.py

### Class `CentralController`  (line 6)
**Methods:**

- `__init__(self, simulator)` (line 7)
    - Calls: range, self.optimize_periodically, self.simulator.env.process
- `optimize_periodically(self)` (line 13)

    periodically run the dynamic channel assignment optimization
    - Calls: self._optimize, self.simulator.env.timeout
- `_optimize(self)` (line 19)

    Channel assignment using genetic algorithm
    - Calls: self._dca_ga, self.channel_assignment_dict.keys, self.channel_assignment_dict.update, zip
- `_fitness_fun_ga(self, x)` (line 25)

    Fitness function of the genetic algorithm, the goal is to minimize the total interference at all drones
    - Calls: abs, general_path_loss, max
- `_dca_ga(self)` (line 40)
    - Calls: GA, best_x.astype, ga.run, tolist

## File: allocation\channel_assignment.py

### Class `ChannelAssigner`  (line 4)
**Docstring:**

```
Class for sub-channel assignment

Sub-channel assignment is important in IEEE 802.11 wireless network since it can handle adjacent channel
interference. Take IEEE 802.11b wireless LANs operated on the 2.4GHz ISM band as an example, there are 14
sub-channels, however, some of them are overlapping, which will cause adjacent channel interference. This part of
work can be further extended to implement more advanced channel assignment algorithms, and support more access
technique like orthogonal frequency-division multiple access as well.

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed this module
    mode: the IEEE 802.11 standard that adopted
    rng_channel_assignment: a Random class based on which we can call the function that generates the random number

References:
    [1] R. Akl and A. Arepally. "Dynamic channel assignment in IEEE 802.11 networks," in 2007 IEEE International
        Conference on Portable Information Devices, 2007, pp. 1-5.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2025/3/30
Updated at: 2025/4/1
```
**Methods:**

- `__init__(self, simulator, my_drone, mode)` (line 29)
    - Calls: random.Random
- `_without_assignment(self)` (line 35)

    This will be served as a baseline
    - Calls: print
- `_random_ondemand_assignment(self)` (line 43)

    Randomly select a certain channel for transmission
    - Calls: print, self.rng_channel_assignment.choice
- `_dynamic_channel_assignment(self)` (line 52)
    - Calls: self.simulator.central_controller.channel_assignment_dict.get
- `adjacent_channel_interference_check(self, channel_id1, channel_id2)` (line 55)

    Determine if the two sub-channel is overlapping
    - Calls: abs, print
- `channel_assign(self)` (line 66)
    - Calls: self._random_ondemand_assignment

## File: energy\energy_model.py

### Class `EnergyModel`  (line 6)
**Docstring:**

```
Implementation of energy model (Y. Zeng2019)

It should be noted that this class mainly calculates the power consumption required for UAV flight, while
communication-related energy consumption does not require a special model.

Attributes:
    delta: profile drag coefficient
    rho: air density
    s: rotor solidity, defined as the ratio of the total blade area to the disc area
    a: rotor disc area
    omega: blade angular velocity in radians/second
    r: rotor radius in meter
    k: incremental correction factor to induced power
    w: aircraft weight in Newton
    u_tip: tip speed of the rotor blade
    v0: mean rotor induced velocity in hover
    d0: fuselage drag ratio

References:
    [1] Y. Zeng, J. Xu and R. Zhang, "Energy Minimization for Wireless Communication with Rotary-wing UAV," IEEE
        transactions on wireless communications, vol. 18, no. 4, pp. 2329-2345, 2019.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/3/21
Updated at: 2025/4/23
```
**Methods:**

- `__init__(self, drone)` (line 35)
    - Calls: self.energy_monitor, self.my_drone.simulator.env.process
- `power_consumption(self, speed)` (line 52)
    - Calls: math.sqrt
- `energy_monitor(self)` (line 62)

    Monitoring energy consumption of drone under a certain energy model
    - Calls: self.my_drone.simulator.env.timeout
- `test(self)` (line 71)
    - Calls: plt.figure, plt.grid, plt.legend, plt.plot, plt.show, plt.xlabel, plt.ylabel, range, self.power_consumption, total_power.append

## File: entities\drone.py

### Class `Drone`  (line 18)
**Docstring:**

```
Drone implementation

Drones in the simulation are served as routers. Each drone can be selected as a potential source node, destination
and relaying node. Each drone needs to install the corresponding routing module, MAC module, mobility module and
energy module, etc. At the same time, each drone also has its own queue and can only send one packet at a time, so
subsequent data packets need queuing for queue resources, which is used to reflect the queue delay in the drone
network

Attributes:
    simulator: the simulation platform that contains everything
    env: simulation environment created by simpy
    identifier: used to uniquely represent a drone
    coords: the 3-D position of the drone
    start_coords: the initial position of drone
    direction: current direction of the drone
    pitch: current pitch of the drone
    speed: current speed of the drone
    velocity: velocity components in three directions
    direction_mean: mean direction
    pitch_mean: mean pitch
    velocity_mean: mean velocity
    inbox: a "Store" in simpy, used to receive the packets from other drones (calculate SINR)
    buffer: used to describe the queuing delay of sending packet
    transmitting_queue: when the next hop node receives the packet, it should first temporarily store the packet in
                "transmitting_queue" instead of immediately yield "packet_coming" process. It can prevent the buffer
                resource of the previous hop node from being occupied all the time
    waiting_list: for reactive routing protocol, if there is no available next hop, it will put the data packet into
                  "waiting_list". Once the routing information bound for a destination is obtained, drone will get
                  the data packets related to this destination, and put them into "transmitting_queue"
    mac_protocol: installed mac protocol (CSMA/CA, ALOHA, etc.)
    mac_process_dict: a dictionary, used to store the mac_process that is launched each time
    mac_process_finish: a dictionary, used to indicate the completion of the process
    mac_process_count: used to distinguish between different "mac_send" processes
    enable_blocking: describe whether the process of waiting for an ACK blocks the delivery of subsequent packets
                     1: stop-and-wait protocol; 0: sliding window (need further implemented)
    routing_protocol: routing protocol installed (GPSR, DSDV, etc.)
    mobility_model: mobility model installed (3-D Gauss-markov, 3-D random waypoint, etc.)
    energy_model: energy consumption model installed
    residual_energy: the residual energy of drone in Joule
    sleep: if the drone is in a "sleep" state, it cannot perform packet sending and receiving operations
    channel_assigner: used to assign sub-channel for transmitting

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/4/16
```
**Methods:**

- `__init__(self, env, node_id, coords, speed, inbox, simulator)` (line 67)
    - Calls: ChannelAssigner, CsmaCa, Dsdv, EnergyModel, GaussMarkov3D, dict, math.cos, math.sin, queue.Queue, random.Random, self.env.process, self.feed_packet, self.generate_data_packet, self.receive, self.rng_drone.uniform, simpy.Resource
- `generate_data_packet(self, traffic_pattern)` (line 121)

    Generate one data packet, it should be noted that only when the current packet has been sent can the next
    packet be started. When the drone generates a data packet, it will first put it into the "transmitting_queue",
    the drone reads a data packet from the head of the queue every very short time through "feed_packet()" function.

    Parameters:
        traffic_pattern: characterize the time interval between generating data packets
    - Calls: DataPacket, all_candidate_list.remove, logger.info, range, round, self.channel_assigner.channel_assign, self.env.timeout, self.rng_drone.choice, self.rng_drone.expovariate, self.rng_drone.randint, self.transmitting_queue.put, self.transmitting_queue.qsize
- `blocking(self)` (line 190)

    The process of waiting for an ACK will block subsequent incoming data packets to simulate the
    "head-of-line blocking problem"
    - Calls: list, self.mac_protocol.wait_ack_process_finish.items
- `feed_packet(self)` (line 212)

    It should be noted that this function is designed for those packets which need to compete for wireless channel

    Firstly, all packets received or generated will be put into the "transmitting_queue", every very short
    time, the drone will read the packet in the head of the "transmitting_queue". Then the drone will check
    if the packet is expired (exceed its maximum lifetime in the network), check the type of packet:
    1) data packet: check if the data packet exceeds its maximum re-transmission attempts. If the above inspection
       passes, routing protocol is executed to determine the next hop drone. If next hop is found, then this data
       packet is ready to transmit, otherwise, it will be put into the "waiting_queue".
    2) control packet: no need to determine next hop, so it will directly start waiting for buffer
    - Calls: isinstance, logger.info, self.blocking, self.env.process, self.env.timeout, self.packet_coming, self.remove_from_queue, self.routing_protocol.next_hop_selection, self.transmitting_queue.empty, self.transmitting_queue.get, self.waiting_list.append
- `packet_coming(self, pkd)` (line 262)

    When drone has a packet ready to transmit, yield it.

    The requirement of "ready" is:
        1) this packet is a control packet, or
        2) the valid next hop of this data packet is obtained

    Parameter:
        pkd: packet that waits to enter the buffer of drone
    - Calls: join, logger.info, self.buffer.request, self.env.process, self.mac_protocol.mac_send, str
- `remove_from_queue(self, data_pkd)` (line 308)

    After receiving the ack packet, drone should remove the data packet that has been acked from its queue

    Parameter:
        data_pkd: the acked data packet
    - Calls: queue.Queue, self.transmitting_queue.empty, self.transmitting_queue.get, self.transmitting_queue.put, temp_queue.empty, temp_queue.get, temp_queue.put
- `receive(self)` (line 325)

    Core receiving function of drone
    1. the drone checks its "inbox" to see if there is incoming packet every 5 units (in us) from the time it is
       instantiated to the end of the simulation
    2. update the "inbox" by deleting the inconsequential data packet
    3. then the drone will detect if it receives a (or multiple) complete data packet(s)
    4. SINR calculation
    - Calls: has_intersection, list, logger.info, max, pkd.get_current_ttl, self.env.process, self.env.timeout, self.routing_protocol.packet_reception, self.trigger, self.update_inbox, sinr_calculator, sinr_list.index, transmitting_node_list.append, tuple
- `update_inbox(self)` (line 388)

    Clear the packets that have been processed.
                                       ↓ (current time step)
                          |==========|←- (current incoming packet p1)
                   |==========|←- (packet p2 that has been processed, but also can affect p1, so reserve it)
    |==========|←- (packet p3 that has been processed, no impact on p1, can be deleted)
    --------------------------------------------------------> time
    - Calls: self.inbox.remove
- `trigger(self)` (line 411)

    Detects whether the drone has received a complete data packet

    Returns:
        flag: bool variable, "1" means a complete data packet has been received by this drone and vice versa
        all_drones_send_to_me: a nested list, whose element is a list including sender id and the channel id
        time_span: a nested list, whose element is a list including the time when the packet is transmitted and the
            time when the packet reached
        potential_packet: a list, including all the instances of the received complete data packet
    - Calls: all_drones_send_to_me.append, potential_packet.append, time_span.append

## File: entities\obstacle.py

### Class `SphericalObstacle`  (line 4)
**Methods:**

- `__init__(self, center, radius, obstacle_id)` (line 5)
- `add_to_grid(self, grid)` (line 10)
    - Calls: euclidean_distance_3d, int, max, min, range, round

### Class `CubeObstacle`  (line 23)
**Methods:**

- `__init__(self, center, length, width, height, obstacle_id)` (line 24)
- `add_to_grid(self, grid)` (line 31)
    - Calls: int, max, min, range, round

## File: entities\packet.py

### Class `Packet`  (line 4)
**Docstring:**

```
Basic properties of the packet

all other packets need to inherit this class

Attributes:
    packet_id: identifier of the packet, used to uniquely represent a packet
    creation_time: the generation time of the packet
    deadline: maximum segment lifetime of packet, in second
    __ttl: current "Time to live (TTL)"
    number_retransmission_attempt: record the number of retransmissions of packet on different drones
    waiting_start_time: the time at which tha packet is added to the "transmitting queue" of drone
    first_attempt_time: the time at which the packet starts the backoff stage
    transmitting_start_time: the time at which the packet can be transmitted to the channel after backoff
    time_delivery: the time at which the packet arrives at its destination
    time_transmitted_at_last_hop: the transmitting time at last drone
    transmission_mode: unicast or multicast or broadcast?
    channel_id: the identity of the channel that used to transmit this packet

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/3/30
```
**Methods:**

- `__init__(self, packet_id, packet_length, creation_time, simulator, channel_id)` (line 29)
- `increase_ttl(self)` (line 60)
- `get_current_ttl(self)` (line 63)

### Class `DataPacket`  (line 67)
**Docstring:**

```
Basic properties of the data packet

Attributes:
    src_drone: source drone that originates the data packet
    dst_drone: destination drone of this data packet
    routing_path: record to whole routing path in centralized routing protocol
    next_hop_id: identifier of the next hop drone

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/3/30
```
**Methods:**

- `__init__(self, src_drone, dst_drone, creation_time, data_packet_id, data_packet_length, simulator, channel_id)` (line 82)
    - Calls: __init__, super

### Class `AckPacket`  (line 99)
**Methods:**

- `__init__(self, src_drone, dst_drone, ack_packet_id, ack_packet_length, ack_packet, simulator, channel_id, creation_time)` (line 100)
    - Calls: __init__, super

## File: mac\csma_ca.py

### Class `CsmaCa`  (line 9)
**Docstring:**

```
Medium access control protocol: CSMA/CA (Carrier Sense Multiple Access With Collision Avoidance) without RTS/CTS

The basic flow of the basic CSMA/CA (without RTS/CTS) is as follows:
    1) when a node has a packet to send, it first needs to wait until the channel is idle
    2) when the channel is idle, the node starts a timer and waits for "DIFS+backoff" periods of time, where the
       length of backoff is related to the number of re-transmissions
    3) if the entire decrement of the timer to 0 is not interrupted, then the node can occupy the channel and start
       sending the data packet and waiting for the corresponding ACK
    4) if the countdown is interrupted, it means that the node loses the game. The node should freeze the timer and
       wait for channel idle again before re-starting its timer

Main attributes:
    my_drone: the drone that installed the CSMA/CA protocol
    simulator: the simulation platform that contains everything
    rng_mac: a Random class based on which we can call the function that generates the random number
    env: simulation environment created by simpy
    phy: the installed physical layer
    channel_states: used to determine if the channel is idle
    enable_ack: use ack or not

References:
    [1] J. Li, et al., "Packet Delay in UAV Wireless Networks Under Non-saturated Traffic and Channel Fading
        Conditions," Wireless Personal Communications, vol. 72, no. 2, pp. 1105-1123, 2013.
    [2] M. A. Siddique and J. Kamruzzaman, "Performance Analysis of M-Retry BEB Based DCF Under Unsaturated Traffic
        Condition," in 2010 IEEE Wireless Communication and Networking Conference, 2010, pp. 1-6.
    [3] F. Daneshgaran, M. Laddomada, F. Mesiti and M. Mondin, "Unsaturated Throughput Analysis of IEEE 802.11 in
        Presence of Non-ideal Transmission Channel and Capture Effects," IEEE transactions on Wireless Communications
        vol. 7, no. 4, pp. 1276-1286, 2008.
    [4] Park, Ki hong, "Wireless Lecture Notes". Purdue. Retrieved 28 September 2012, link:
        https://www.cs.purdue.edu/homes/park/cs536-wireless-3.pdf

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, drone)` (line 47)
    - Calls: Phy, dict, random.Random
- `mac_send(self, pkd)` (line 61)

    Control when drone can send packet
    :param pkd: the packet that needs to send
    :return: none
    - Calls: join, logger.info, pkd.increase_ttl, request, self.env.process, self.env.timeout, self.listen, self.phy.broadcast, self.phy.unicast, self.rng_mac.randint, self.wait_ack, self.wait_idle_channel, str
- `wait_ack(self, pkd)` (line 157)

    If ACK is received within the specified time, the transmission is successful, otherwise,
    a re-transmission will be originated
    :param pkd: the data packet that waits for ACK
    :return: none
    - Calls: join, logger.info, self.env.process, self.env.timeout, self.my_drone.packet_coming, self.my_drone.routing_protocol.penalize, self.simulator.metrics.mac_delay.append, str
- `wait_idle_channel(self, sender_drone, drones)` (line 189)

    Wait until the channel becomes idle
    :param sender_drone: the drone that is about to send packet
    :param drones: a list, which contains all the drones in the simulation
    :return: none
    - Calls: check_channel_availability, self.env.timeout
- `listen(self, channel_states, drones, pkd)` (line 200)

    When the drone waits until the channel is idle, it starts its own timer to count down, in this time, the drone
    needs to detect the state of the channel during this period, and if the channel is found to be busy again, the
    countdown process should be interrupted
    :param channel_states: a dictionary, indicates the use of the channel by different drones
    :param drones: a list, contains all drones in the simulation
    :param pkd: listen to the channel for which packet
    :return: none
    - Calls: check_channel_availability, interrupt, join, logger.info, self.env.timeout, str

## File: mac\pure_aloha.py

### Class `PureAloha`  (line 8)
**Docstring:**

```
Pure ALOHA protocol

This protocol allows devices to transmit packet at any time, without a set schedule. After transmitting a packet,
the drone should wait for the ACK packet. If it fails to receive the corresponding ACK packet after a period of time,
the drone will simply wait a random amount of time before attempting to transmit again.

The basic flow of the Pure ALOHA is as follows:
    1) when a node has a packet to send, it just sends it, without listening to the channel and random backoff
    2) after sending the packet, the node starts to wait for the ACK
    3) if it receives ACK, the mac_send process will finish
    4) if not, the node will wait a random amount of time, according to the number of re-transmissions attempts

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/22
Updated at: 2025/4/16
```
**Methods:**

- `__init__(self, drone)` (line 27)
    - Calls: Phy, dict, random.Random
- `mac_send(self, pkd)` (line 41)
    - Calls: join, logger.info, pkd.increase_ttl, self.env.process, self.env.timeout, self.phy.broadcast, self.phy.unicast, self.wait_ack, str
- `wait_ack(self, pkd)` (line 86)

    If ACK is received within the specified time, the transmission is successful, otherwise,
    a re-transmission will be originated
    :param pkd: the data packet that waits for ACK
    :return: none
    - Calls: join, logger.info, self.env.process, self.env.timeout, self.my_drone.packet_coming, self.my_drone.routing_protocol.penalize, self.rng_mac.randint, self.simulator.metrics.mac_delay.append, str

## File: mac\tdma.py

### Class `Tdma`  (line 8)
**Docstring:**

```
Medium access control protocol: TDMA (Time Division Multiple Access) following IEEE 802.11

The basic flow of TDMA is as follows:
    1) Time is divided into frames, and each frame is divided into time slots
    2) Each node is assigned one or more time slots within a frame
    3) A node can only transmit during its assigned time slot(s)
    4) The node must wait for its slot even if the channel is idle
    5) ACK is sent in the same slot or in a designated ACK period

Main attributes:
    my_drone: the drone that installed the TDMA protocol
    simulator: the simulation platform that contains everything
    rng_mac: a Random class for generating random numbers
    env: simulation environment created by simpy
    phy: the installed physical layer
    channel_states: used to determine if the channel is idle
    enable_ack: use ack or not
    slot_assignment: dictionary mapping drone IDs to their assigned slots
    frame_duration: duration of one TDMA frame
    slot_duration: duration of one time slot
    current_slot: the current slot number in the frame

References:
    [1] IEEE 802.11 Standard for Wireless LAN Medium Access Control (MAC) and
        Physical Layer (PHY) Specifications
    [2] A. Boukerche, "Algorithms and Protocols for Wireless, Mobile Ad Hoc Networks,"
        Wiley-IEEE Press, 2008.
    [3] C. E. Perkins, "Ad Hoc Networking," Addison-Wesley, 2001.

Author: Github @hkphimanshukumar321, some modifications by Zihao Zhou
Created at: 2026/1/13
Updated at: 2026/1/20
```
**Methods:**

- `__init__(self, drone)` (line 44)
    - Calls: Phy, dict, random.Random, range, self._initialize_slot_assignment
- `_initialize_slot_assignment(self)` (line 68)

    Initialize slot assignments for all drones
    Strategy: Round-robin assignment or can be customized
    :return: dictionary mapping drone_id to list of assigned slot numbers
    - Calls: list, logger.info, self.drone_id_dict.keys
- `_get_wait_time(self)` (line 83)

    Calculate the start time of the next assigned slot for this drone
    :return: time to wait until next slot (in us)
- `mac_send(self, pkd)` (line 113)

    Control when drone can send packet using TDMA
    :param pkd: the packet that needs to send
    :return: none
    - Calls: join, logger.info, logger.warning, pkd.increase_ttl, request, self._get_wait_time, self.env.process, self.env.timeout, self.phy.broadcast, self.phy.unicast, self.wait_ack, str
- `wait_ack(self, pkd)` (line 186)

    If ACK is received within the specified time, the transmission is successful, otherwise,
    a re-transmission will be scheduled for the next available slot
    :param pkd: the data packet that waits for ACK
    :return: none
    - Calls: join, logger.info, self.env.process, self.env.timeout, self.my_drone.packet_coming, self.my_drone.routing_protocol.penalize, self.simulator.metrics.mac_delay.append, str

## File: mobility\gauss_markov_3d.py

### Class `GaussMarkov3D`  (line 9)
**Docstring:**

```
3-D Gauss-Markov Mobility Model

In this memorized model, the trajectory and velocity of the next motion at any time and any position
depends on its previous position and velocity vector. There are three main parameters: 1) The first parameter
is to determine how often the drone updates its position, velocity and other information, the denser this time
interval is, the higher the simulation accuracy. 2) The second parameter is to determine how often the drone
changes its velocity, direction, and other information. The smaller the interval is, the drone will change its
motion direction frequently. 3) The last parameter is to control the randomness of the mobility.

Attributes:
    model_identifier: model name
    my_drone: the drone that installed the mobility model
    position_update_interval: unit: us, determine how often the drone updates its position
    direction_update_interval: unit: us, determine how often the drone changes its direction
    alpha: control the randomness of the mobility
    move_counter: control the random seed
    b1, b2, b3: buffer zone, avoid getting too close to the boundary

References:
    [1] Broyles D, Jabbar A., "Design and Analysis of a 3-D Gauss-Markov Model for Highly Dynamic Airborne
        Networks," in Proceedings of International Foundation for Telemetering, 2010.
    [2] ns-3 https://www.nsnam.org/docs/release/3.39/doxygen/d4/d4d/classns3_1_1_gauss_markov_mobility_model.html

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/17
Updated at: 2025/4/12
```
**Methods:**

- `__init__(self, drone)` (line 39)
    - Calls: random.Random, self.mobility_update, self.my_drone.simulator.env.process, self.show_trajectory
- `mobility_update(self, drone)` (line 66)
    - Calls: drone.energy_model.power_consumption, env.timeout, math.cos, math.sin, math.sqrt, self.boundary_test, self.rng_mobility.normalvariate, self.trajectory.append
- `show_trajectory(self)` (line 139)
    - Calls: ax.plot, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, len, np.array, plt.axes, plt.figure, plt.show, range, self.my_drone.simulator.env.timeout, x.append, y.append, z.append
- `boundary_test(self, next_position, next_velocity, direction_mean, pitch_mean)` (line 167)
    - Calls: max, min

## File: mobility\random_walk_3d.py

### Class `RandomWalk3D`  (line 9)
**Docstring:**

```
3-D Random walk mobility model

In this model, firstly, the drone will randomly choose a direction of motion, and move along this direction for a
fixed amount of time ("travel_duration"). In addition to this, it is also possible to specify the drone to move a
fixed distance in this direction. In this code, we assume that the speed of drone is constant.

Attributes:
    my_drone: the drone which installs this mobility model
    move_counter
    position_update_interval: in us, determine how often the drone updates its position
    travel_duration: specifies the time for a node to move in a certain direction
    b1, b2, b3: safety boundary of x-, y- and z-axis, respectively
    min_x, max_x: Boundaries on the length of the map
    min_y, max_y: Boundaries on the width of the map
    min_z, max_z: Boundaries on the height of the map
    trajectory: list, used to record the flying trajectories of a certain drone

References:
    [1] Roy, R.R. (2011). Random Walk Mobility. In: Handbook of Mobile Ad Hoc Networks for Mobility Models.
        Springer, Boston, MA. https://doi.org/10.1007/978-1-4419-6050-4_3
    [2] NS-3 for 2D Random walk mobility model:
        https://www.nsnam.org/docs/release/3.20/doxygen/classns3_1_1_random_walk2d_mobility_model.html


Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/20
Updated at: 2025/1/7
```
**Methods:**

- `__init__(self, drone)` (line 39)
    - Calls: random.Random, self.mobility_update, self.my_drone.simulator.env.process, self.show_trajectory
- `mobility_update(self, drone)` (line 64)
    - Calls: drone.energy_model.power_consumption, env.timeout, math.cos, math.sin, self.boundary_test, self.rng_mobility.uniform, self.trajectory.append
- `show_trajectory(self)` (line 125)
    - Calls: ax.plot, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, len, np.array, plt.axes, plt.figure, plt.show, range, self.my_drone.simulator.env.timeout, x.append, y.append, z.append
- `boundary_test(self, next_position, next_velocity, next_direction, next_pitch)` (line 154)
    - Calls: max, min

## File: mobility\random_waypoint_3d.py

### Class `RandomWaypoint3D`  (line 9)
**Docstring:**

```
3-D Random Waypoint Mobility Model

In this mobility model, the waypoint of drone will be generated in advance. Then drone will visit these waypoints
in order. When the drone reached the waypoint, it will pause for a while, and then start heading down to the next
waypoint. Normally, we will set up multiple waypoints as many as possible to prevent the drone visiting all the
waypoints before the simulation is finished.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/19
Updated at: 2025/4/12
```
**Methods:**

- `__init__(self, drone)` (line 23)
    - Calls: random.Random, range, self.mobility_update, self.my_drone.simulator.env.process, self.show_trajectory, self.waypoint_generator
- `waypoint_generator(self, start_coords)` (line 58)
    - Calls: range, ranges_x.append, ranges_y.append, ranges_z.append, self.rng_mobility.choice, self.rng_mobility.uniform, self.waypoint_coords.append
- `get_first_unvisited_waypoint(self)` (line 95)
    - Calls: self.waypoint_visited.index
- `mobility_update(self, drone)` (line 103)
    - Calls: calculate_velocity, drone.energy_model.power_consumption, env.timeout, euclidean_distance_3d, self.get_first_unvisited_waypoint, self.trajectory.append
- `show_trajectory(self)` (line 137)
    - Calls: ax.plot, ax.scatter, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, len, np.array, plt.axes, plt.figure, plt.show, print, range, self.my_drone.simulator.env.timeout, x.append, y.append, z.append

### Function `calculate_velocity(current_pos, target_pos, moving_speed)`  (line 171)
**Calls:** euclidean_distance_3d, zip

## File: mobility\start_coords.py

### Function `get_random_start_point_3d(sim_seed)`  (line 6)
**Calls:** random.seed, random.uniform, range, start_positions.append, tuple

### Function `get_customized_start_point_3d()`  (line 18)
**Calls:** input, input_str.split, map, range, start_positions.append, tuple

## File: path_planning\astar\astar.py

### Function `get_valid_neighbor_pos(current_pos, grid)`  (line 20)
**Calls:** int, neighbors.append

### Function `a_star_3d(start_pos, end_pos, grid)`  (line 55)
**Docstring:**

```
Implementation of the A* algorithm for 3D path planning

Args:
    start_pos: starting position of the drone, tuple(list)
    end_pos: ending position of the drone, tuple(list)
    grid: the 3D mesh

Returns: the path (if it exists)
```
**Calls:** PriorityQueue, ValueError, all, dict, euclidean_distance_3d, frontier.empty, frontier.get, frontier.put, get_valid_neighbor_pos, int, path.append, path.reverse, tuple, zip

## File: path_planning\path_following_3d.py

### Function `calculate_velocity(current_pos, target_pos, moving_speed)`  (line 7)
**Calls:** euclidean_distance_3d, zip

### Class `PathFollowing3D`  (line 16)
**Docstring:**

```
This path following class will be used when you calculate the flight trajectory in advance (usually in the
form of "waypoint"), and this class will let the drone fly according to the path you want. It is similar to
3D Random Waypoint mobility model, the difference is in here, the waypoint is not generated randomly, but is
set as a parameter "path" instead.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2025/7/9
Updated at: 2025/7/9
```
**Methods:**

- `__init__(self, drone, path)` (line 28)
    - Calls: len, range, self.mobility_update, self.my_drone.simulator.env.process, self.show_trajectory
- `get_first_unvisited_waypoint(self)` (line 45)
    - Calls: self.waypoint_visited.index
- `mobility_update(self, drone)` (line 53)
    - Calls: calculate_velocity, drone.energy_model.power_consumption, env.timeout, euclidean_distance_3d, self.get_first_unvisited_waypoint, self.trajectory.append
- `show_trajectory(self)` (line 86)
    - Calls: ax.plot, ax.scatter, ax.set_box_aspect, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, len, np.array, plt.axes, plt.figure, plt.show, range, self.my_drone.simulator.env.timeout, x.append, y.append, z.append

## File: phy\channel.py

### Class `Channel`  (line 6)
**Docstring:**

```
Wireless channel of the physical layer

Format of pipes:
{UAV 0: [ [message 1], [message 2], ...],
 UAV 1: [ [message 1], [message 3], ...],
 ...
 UAV N: [ [message m], [message n], ...]}

Attributes:
    env: simulation environment created by simpy
    pipes: control the inboxes of all drones, format is shown above

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2024/4/25
```
**Methods:**

- `__init__(self, env)` (line 25)
    - Calls: defaultdict
- `broadcast_put(self, value)` (line 29)

    Broadcast support
    :param value: packet that needs to broadcast
    :return: none
    - Calls: append, copy.copy, logging.error, self.pipes.keys
- `unicast_put(self, value, dst_id)` (line 44)

    Unicast support
    :param value: packet that needs to unicast
    :param dst_id: next hop id for transmitting this packet
    :return: none
    - Calls: append, logging.error, self.pipes.keys
- `multicast_put(self, value, dst_id_list)` (line 57)

    Multicast support
    :param value: packet that needs to multicast
    :param dst_id_list: next hop list
    :return: none
    - Calls: append, copy.copy, logging.error, self.pipes.keys
- `create_inbox_for_receiver(self, identifier)` (line 72)

## File: phy\large_scale_fading.py

### Function `sinr_calculator(my_drone, main_drones_list, all_transmitting_drones_list)`  (line 7)
**Docstring:**

```
calculate signal to signal-to-interference-plus-noise ratio

Parameters:
    my_drone: receiver drone
    main_drones_list: list of drones that wants to transmit packet to receiver
    all_transmitting_drones_list: list of all drones currently transmitting packet

Returns:
    List of sinr of each main drone
```
**Calls:** general_path_loss, len, logger.info, math.log10, my_drone.channel_assigner.adjacent_channel_interference_check, range, real_interference_nodes.append, sinr_list.append

### Function `general_path_loss(receiver, transmitter)`  (line 71)
**Docstring:**

```
General path loss model of line-of-sight (LoS) channels without system loss

References:
    [1] J. Sabzehali, et al., "Optimizing number, placement, and backhaul connectivity of multi-UAV networks," in
        IEEE Internet of Things Journal, vol. 9, no. 21, pp. 21548-21560, 2022.

Parameters:
    receiver: the drone that receives the packet
    transmitter: the drone that sends the packet

Returns:
    path loss
```
**Calls:** euclidean_distance_3d

### Function `probabilistic_los_path_loss(receiver, transmitter)`  (line 100)
**Docstring:**

```
probabilistic loss mode

References:
    [1] A. Al-Hourani, S. Kandeepan and S. Lardner, "Optimal LAP Altitude for Maximum Coverage," in IEEE Wireless
        Communications Letters, vol. 3, no. 6, pp. 569-572, 2014.
    [2] J. Sabzehali, et al., "Optimizing number, placement, and backhaul connectivity of multi-UAV networks," in
        IEEE Internet of Things Journal, vol. 9, no. 21, pp. 21548-21560, 2022.

Parameters:
    receiver: the drone that receives the packet
    transmitter: the drone that sends the packet

Returns:
    path loss
```
**Calls:** euclidean_distance_2d, euclidean_distance_3d, math.atan, math.exp, max

### Function `maximum_communication_range()`  (line 146)
**Calls:** math.log10

## File: phy\phy.py

### Class `Phy`  (line 12)
**Docstring:**

```
Physical layer implementation

Attributes:
    mac: mac protocol that installed
    env: simulation environment created by simpy
    my_drone: the drone that installed the physical protocol

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/3/30
```
**Methods:**

- `__init__(self, mac)` (line 26)
- `unicast(self, packet, next_hop_id)` (line 31)

    Unicast packet through the wireless channel

    Parameters:
        packet: the data packet or ACK packet that needs to be transmitted
        next_hop_id: the identifier of the next hop drone
    - Calls: self.my_drone.simulator.channel.unicast_put
- `broadcast(self, packet)` (line 49)

    Broadcast packet through the wireless channel

    Parameters:
    packet: tha packet (hello packet, etc.) that needs to be broadcast
    - Calls: self.my_drone.simulator.channel.broadcast_put
- `multicast(self, packet, dst_id_list)` (line 66)

    Multicast packet through the wireless channel

    Parameters:
        packet: tha packet that needs to be multicasted
        dst_id_list: list of ids for multicast destinations
    - Calls: self.env.timeout, self.my_drone.simulator.channel.multicast_put

## File: routing\dsdv\dsdv.py

### Class `Dsdv`  (line 11)
**Docstring:**

```
Main procedure of DSDV (v2.0)

In this version of code, when the broken link is detected, the node will broadcast its new routing table, for all
its neighboring nodes, after receiving the update packet, the neighbors update their routing table, and then
re-transmit the update packet to the corresponding neighbors of each of them. The process will be repeated until
all the other nodes in the network have received a copy of the update packet.

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the DSDV
    rng_routing: a Random class based on which we can call the function that generates the random number
    hello_interval: interval of sending hello packet
    routing_table: routing table of DSDV
    processed_hello_packet: used to record the id of update packet that has been processed

References:
    [1] C. Perkins, and P. Bhagwat,"Highly dynamic destination-sequenced distance-vector routing (DSDV) for
        mobile computer," ACM SIGCOMM computer communication review, vol. 24, no. 4, pp. 234-244, 1994.
    [2] G. He, "Destination-sequenced distance vector (DSDV) protocol," Networking Laboratory, Helsinki University
        of Technology, 135, pp. 1-9, 2002.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/14
Updated at: 2025/4/22
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 39)
    - Calls: DsdvRoutingTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.detect_broken_link_periodically, self.simulator.env.process
- `detect_broken_link_periodically(self, my_drone)` (line 52)

    If a node finds that it has not received a hello packet from a neighbor for more than a period of time, it can
    be considered that the link is broken and an update packet needs to be broadcast immediately

    Parameters:
        my_drone: the node that installs the protocol
    - Calls: DsdvHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put, self.routing_table.purge, self.simulator.env.timeout
- `broadcast_hello_packet(self, my_drone)` (line 87)
    - Calls: DsdvHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 110)
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 116)

    Select the next hop according to the routing table

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        Next hop drone
    - Calls: self.routing_table.has_entry
- `packet_reception(self, packet, src_drone_id)` (line 140)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: AckPacket, DsdvHelloPacket, VfPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, join, logger.info, receive, self.my_drone.channel_assigner.channel_assign, self.my_drone.mac_protocol.phy.unicast, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.processed_hello_packet.append, self.routing_table.update_item, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.simulator.metrics.mac_delay.append, str
- `check_waiting_list(self)` (line 279)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.next_hop_selection, self.simulator.env.timeout
- `penalize(self, packet)` (line 297)

## File: routing\dsdv\dsdv_packet.py

### Class `DsdvHelloPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, packet_type, routing_table, simulator, channel_id)` (line 5)
    - Calls: __init__, super

## File: routing\dsdv\dsdv_routing_table.py

### Class `DsdvRoutingTable`  (line 6)
**Docstring:**

```
Routing table of DSDV (Destination-Sequenced Distance Vector)

type of the routing table: dictionary
the structure of the routing table is:
{dst1: [next hop, metric (hop count), seq_num of dst1, updated time1],
 dst2: [next hop, metric (hop count), seq_num of dst2, updated time2],
 ...}

Attributes:
    env: simulation environment
    routing_table: dictionary in python, core member
    entry_life_time: lifetime of each item in the neighbor table

References:
    [1] Perkins, C. E., and Bhagwat, P.,"Highly dynamic destination-sequenced distance-vector routing (DSDV) for
        mobile computer," ACM SIGCOMM computer communication review, vol. 24, no. 4, pp. 234-244, 1994.
    [2] He. G, "Destination-sequenced distance vector (DSDV) protocol," Networking Laboratory, Helsinki University
        of Technology, 135, pp. 1-9, 2002.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/14
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, env, my_drone)` (line 32)
    - Calls: defaultdict
- `is_empty(self)` (line 42)
    - Calls: bool
- `get_updated_time(self, drone_id)` (line 46)
    - Calls: RuntimeError, self.routing_table.keys
- `update_item(self, packet, cur_time)` (line 53)
    - Calls: packet.routing_table.keys, self.routing_table.keys
- `purge(self)` (line 70)
    - Calls: bool, float, list, self.get_updated_time
- `has_entry(self, dst_id)` (line 94)
    - Calls: float, self.routing_table.keys
- `print_neighbor(self, my_drone)` (line 106)
    - Calls: logger.info, self.routing_table.keys

## File: routing\grad\grad.py

### Class `Grad`  (line 9)
**Docstring:**

```
Main procedure of GRAd (Gradient Routing in ad hoc networks) (v1.0)

Slight changes have been made to the original paper:
On transmitting data packet:
1) When a drone wishes to send a data packet to a destination for which the cost to the target is known, it will
   embed the data packet in "GradMessage" with the "msg_type" filed set to "M_DATA", and then broadcast
2) When a drone wishes to send a data packet to another drone for which there is no entry in the cost table, it
   initiates a request process. Similarly, the originator drone will transmit "GradMessage" whose "msg_type" filed
   is set to "M_REQUEST", specifying the destination in the "target_id", initializing the "remaining_value" field
   to "default_request_cost", "accrued_cost" field to "0", and then broadcast

On receiving packet:
Some important things that every receiving drone must do:
1) When the drone receives a message from its neighbor, it debits the "remaining_value" field by one and increases
   the "accrued_cost" by one
2) update its cost table according to the incoming message

Other type-related procedures:
1) if "msg_type" field is "M_DATA", before reaching the destination, only those drones with a lower cost than the
   "remain_value" in the message can further forward
2) if "msg_type" field is "M_REQUEST", when I am the "target drone", reply message should be launched. For other
   drones, they will always relay the first copy of the message they receive, unless the "remaining_value" field
   has reached zero
3) if "msg_type" field is "M_REPLY", when I am the "target drone" of this reply message, it means that now I know
   the routing information of the data packets stored in my "waiting_list". Therefore, all data packets destined for
   the originator of REPLY message in "waiting_list" are taken out and put into the "transmitting_queue". For other
   drones, only those drones with a lower cost than the "remain_value" in the REPLY message can further forward

References:
    [1] Poor R. Gradient routing in ad hoc networks[J]. 2000.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/20
Updated at: 2025/4/22
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 47)
    - Calls: GradCostTable
- `next_hop_selection(self, packet)` (line 54)
    - Calls: GradMessage, copy.copy, grad_message.attached_data_packet.increase_ttl, self.cost_table.get_est_cost, self.cost_table.has_entry, self.cost_table.purge, self.my_drone.channel_assigner.channel_assign, self.my_drone.waiting_list.append
- `packet_reception(self, packet, src_drone_id)` (line 112)
    - Calls: GradMessage, VfPacket, copy.copy, isinstance, logger.info, logger.warning, self.cost_table.get_est_cost, self.cost_table.has_entry, self.cost_table.update_entry, self.flag.keys, self.my_drone.channel_assigner.channel_assign, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics

## File: routing\grad\grad_cost_table.py

### Class `GradCostTable`  (line 4)
**Docstring:**

```
Cost table of GRAd (Gradient Routing in ad hoc networks) (v1.0)

Type of the cost table: dictionary
the format of the cost table is:
{target_id 1: [seq_#, est_cost1, updated time1], target_id 2: [seq_#, est_cost2, updated time2],...}
Explanation:
1) "target_id": is the identifier of a remote drone to which this cost entry refers
2) "seq_#": the highest sequence number received so far in a message from "target_id". When compared against the
    seq_# of a newly arrived message, this field discriminates between a new message and a copy of a previously
    received message
3) "est_cost": the most recent and best estimated cost (number of hops in this version) for delivering a message
    to "target_id"
4) "updated time": this field is used to determine if the entry is expired

The cost table can answer two question:
1) "Is this message a copy of a previously received message?" This is determined by comparing the sequence number
    in the incoming message against the last sequence number recorded in the cost table
2) "What is the estimated cost of sending a message to a certain target drone?" In cost table, each "target_id" is
    associated with "est_cost"

References:
    [1] Poor R. Gradient routing in ad hoc networks[J]. 2000.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/4/20
Updated at: 2024/4/20
```
**Methods:**

- `__init__(self, env, my_drone)` (line 34)
    - Calls: defaultdict
- `is_empty(self)` (line 41)
    - Calls: bool
- `get_est_cost(self, target_id)` (line 45)
    - Calls: RuntimeError, self.cost_table.keys
- `get_updated_time(self, drone_id)` (line 52)
    - Calls: RuntimeError, self.cost_table.keys
- `remove_entry(self, drone_id)` (line 59)
- `purge(self)` (line 63)
    - Calls: list, self.get_updated_time, self.is_empty, self.remove_entry
- `update_entry(self, grad_message, cur_time)` (line 74)
    - Calls: self.cost_table.keys
- `has_entry(self, target_id)` (line 91)
    - Calls: self.cost_table.keys
- `print_cost_table(self)` (line 98)
    - Calls: print, self.cost_table.keys

## File: routing\grad\grad_packet.py

### Class `GradMessage`  (line 4)
**Methods:**

- `__init__(self, src_drone, dst_drone, creation_time, id_message, message_length, message_type, accrued_cost, remaining_value, simulator, channel_id)` (line 5)
    - Calls: __init__, super

## File: routing\greedy\greedy.py

### Class `Greedy`  (line 11)
**Docstring:**

```
Main procedure of Greedy Forwarding

In greedy forwarding approach, packets are forwarded to the neighbor located closest to the destination at each hop.
Greedy routing is highly efficient for the route discovery process, however, the problem of local minimum will
significantly limit its performance. Users can extend it by adding some recovery mechanism to improve the
performance.

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the greedy routing
    rng_routing: a Random class based on which we can call the function that generates the random number
    hello_interval: interval of sending hello packet
    neighbor_table: neighbor table of greedy routing

References:
    [1] N. K. Gupta, R. S. Yadav and R. K. Nagaria, "3D geographical routing protocols in wireless ad hoc and sensor
        networks: An overview," in Wireless Networks, vol. 26, pp. 2549-2566, 2020.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 36)
    - Calls: GreedyNeighborTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.simulator.env.process
- `broadcast_hello_packet(self, my_drone)` (line 46)
    - Calls: GreedyHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 66)
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 72)

    Select the next hop according to the routing protocol

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        next hop drone id
    - Calls: self.neighbor_table.best_neighbor, self.neighbor_table.purge
- `packet_reception(self, packet, src_drone_id)` (line 101)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: AckPacket, VfPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, join, logger.info, receive, self.my_drone.channel_assigner.channel_assign, self.my_drone.mac_protocol.phy.unicast, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.neighbor_table.add_neighbor, self.neighbor_table.print_neighbor, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.simulator.metrics.mac_delay.append, str
- `check_waiting_list(self)` (line 225)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.neighbor_table.best_neighbor, self.simulator.env.timeout
- `penalize(self, packet)` (line 243)

## File: routing\greedy\greedy_neighbor_table.py

### Class `GreedyNeighborTable`  (line 6)
**Docstring:**

```
Neighbor table of Greedy Forwarding

type of the neighbor table: dictionary
the structure of the neighbor table is: {drone1: [coords1, updated time1], drone2: [coords2, updated time2],...}
each item in the neighbor table has its lifetime, if the hello packet from a drone has not been received for more
than a certain time, it can be considered that this drone has flown out of my communication range. Therefore, the
item associated with this drone is removed from my neighbor table

Attributes:
    env: simulation environment
    neighbor_table: dictionary in python, core member
    entry_life_time: lifetime of each item in the neighbor table
    have_void_area: used to indicate if encounters void area

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, env, my_drone)` (line 27)
    - Calls: defaultdict
- `is_empty(self)` (line 35)
    - Calls: bool
- `get_updated_time(self, drone_id)` (line 39)
    - Calls: RuntimeError, self.neighbor_table.keys
- `add_neighbor(self, hello_packet, cur_time)` (line 45)

    Update the neighbor table according to the hello packet
    :param hello_packet: the received hello packet
    :param cur_time: the moment when the packet is received
    :return: None
- `remove_neighbor(self, drone_id)` (line 58)
- `is_neighbor(self, certain_drone)` (line 62)
    - Calls: self.neighbor_table.keys
- `get_neighbor_position(self, certain_drone)` (line 67)
    - Calls: RuntimeError, self.is_neighbor
- `purge(self)` (line 75)
    - Calls: bool, list, self.get_updated_time, self.remove_neighbor
- `print_neighbor(self, my_drone)` (line 86)
    - Calls: logger.info
- `clear(self)` (line 94)
    - Calls: self.neighbor_table.clear
- `best_neighbor(self, my_drone, dst_drone)` (line 97)

    Choose the best next hop according to the neighbor table
    :param my_drone: the drone that installed the GPSR
    :param dst_drone: the destination of the data packet
    :return: none
    - Calls: euclidean_distance_3d, self.neighbor_table.keys

## File: routing\greedy\greedy_packet.py

### Class `GreedyHelloPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, simulator, channel_id)` (line 5)
    - Calls: __init__, super

## File: routing\opar\opar.py

### Class `Opar`  (line 12)
**Docstring:**

```
Main procedure of Opar (v3.0)

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the routing protocol
    cost: cost matrix, used to record the cost of all links
    best_obj: the minimum objective function value under all iterations
    best_path: optimal routing path corresponding to "best_obj"
    w1: weight of the first term in objective function
    w2: weight of the second term in objective function
    max_comm_range: maximum communication range corresponding to the snr threshold

References:
    [1] M. Gharib, F. Afghah and E. Bentley, "OPAR: Optimized Predictive and Adaptive Routing for Cooperative UAV
        Networks," in IEEE Conference on Computer Communications Workshops, PP. 1-6, 2021.
    [2] M. Gharib, F. Afghah and E. Bentley, "LB-OPAR: Load Balanced Optimized Predictive and Adaptive Routing for
        Cooperative UAV Networks," Ad hoc Networks, vol. 132, pp. 102878, 2022.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/3/19
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 37)
    - Calls: maximum_communication_range, self.check_waiting_list, self.simulator.env.process
- `calculate_cost_matrix(self)` (line 50)
    - Calls: cost.fill, euclidean_distance_3d, np.zeros, range
- `dijkstra(self, cost, src_id, dst_id, minimum_link_lifetime)` (line 65)

    Dijkstra's algorithm to find the shortest path
    :param cost: cost matrix
    :param src_id: source node id
    :param dst_id: destination node id
    :param minimum_link_lifetime: used to determine which edges cannot be considered in this iteration
    :return: routing path that has the minimum total cost
    - Calls: enumerate, link_lifetime_predictor, min, path.insert, range
- `next_hop_selection(self, packet)` (line 120)
    - Calls: len, link_lifetime_predictor, path.pop, range, routing_path.pop, self.best_path.pop, self.calculate_cost_matrix, self.dijkstra
- `packet_reception(self, packet, src_drone_id)` (line 214)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer
    :param packet: the received packet
    :param src_drone_id: previous hop
    :return: None
    - Calls: AckPacket, VfPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, join, logger.info, receive, self.my_drone.mac_protocol.phy.unicast, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.simulator.metrics.mac_delay.append, str
- `check_waiting_list(self)` (line 326)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.next_hop_selection, self.simulator.env.timeout
- `penalize(self, packet)` (line 343)

### Function `link_lifetime_predictor(drone1, drone2, max_comm_range)`  (line 347)
**Calls:** math.sqrt, max

## File: routing\q_routing\q_routing.py

### Class `QRouting`  (line 11)
**Docstring:**

```
Main procedure of Q-routing

The core idea of this protocol is using Q-learning to approximate the end-to-end delay of packet transmission.
The update of Q-values was implemented by ACK packet. It should be noted that the implementation in this project is
sightly different from the original paper regrading to the calculation of transmission delay "s", because in highly
dynamic network, the reply of ACK packet will fail due to many different factors.

Calculation example:
For a drone "x", it has a data packet bound for destination "d", after checking its Q-table, it selects its neighbor
drone "y" with minimum Q-value Q_x(d, y) as the next hop. Then drone "x" transmits this data packet to "y". When "y"
receives the data packet from "x", it will reply an ACK packet to "x", which carries serval information listed below:
1. t = min Q_y(d, z): represents drone y's estimation for the time remaining in the trip.
2. q: queuing delay in drone "x"

When drone "x" receives the ACK packet from "y", it first calculates the real transmission delay "s" (Note that one
cannot simply divide the data packet length by the bit rate, as re-transmission may also be included). Then drone
"x" updates the Q-value of "y" using the following formula:

Q_x(d, y) <-- (1 - a) * Q_x(d, y) + a * (q + s + t)

In a nutshell, the protocol proposed in this paper can be considered as a kind of online learning protocol, where
each drone can interact with its neighbors and updates its policy online. No replay buffer and each drone should
maintain its own Q-table. However, if the topology of the network changes rapidly, the learning speed will be a
problem. Besides, the update mechanism by ACK may be unsatisfactory in the situation of bad channel condition.

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the Q-routing
    rng_routing: a Random class based on which we can call the function that generates the random number
    hello_interval: interval of sending hello packet
    learning_rate: used to guide the degree to which the Q-value is updated
    table: including neighbor table and Q-table

References:
    [1] J. Boyan and M. Littman, "Packet Routing in Dynamically Changing Networks: A Reinforcement Learning
        Approach," Advances in Neural Information Processing Systems (NIPS), no. 6, 1993.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/8/20
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 56)
    - Calls: QRoutingTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.simulator.env.process
- `broadcast_hello_packet(self, my_drone)` (line 67)
    - Calls: QRoutingHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 87)
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 93)

    Select the next hop according to the routing protocol

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        Next hop drone
    - Calls: packet.intermediate_drones.append, self.table.best_neighbor, self.table.purge
- `packet_reception(self, packet, src_drone_id)` (line 123)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: QRoutingAckPacket, VfPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, join, logger.info, receive, self.my_drone.mac_protocol.phy.unicast, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.table.add_neighbor, self.table.get_min_q_value, self.update_q_table, str
- `update_q_table(self, packet, next_hop_id)` (line 257)
    - Calls: self.simulator.metrics.mac_delay.append
- `check_waiting_list(self)` (line 280)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.next_hop_selection, self.simulator.env.timeout
- `penalize(self, packet)` (line 297)

## File: routing\q_routing\q_routing_packet.py

### Class `QRoutingHelloPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, simulator, channel_id)` (line 5)
    - Calls: __init__, super

### Class `QRoutingAckPacket`  (line 18)
**Methods:**

- `__init__(self, src_drone, dst_drone, ack_packet_id, ack_packet_length, ack_packet, transmitting_start_time, queuing_delay, min_q, simulator, channel_id, creation_time)` (line 19)
    - Calls: __init__, super

## File: routing\q_routing\q_routing_table.py

### Class `QRoutingTable`  (line 7)
**Methods:**

- `__init__(self, env, my_drone, rng_routing)` (line 8)
    - Calls: defaultdict, np.ones
- `is_empty(self)` (line 17)
    - Calls: bool
- `get_updated_time(self, drone_id)` (line 21)
    - Calls: RuntimeError, self.neighbor_table.keys
- `add_neighbor(self, hello_packet, cur_time)` (line 27)

    Update the neighbor table according to the hello packet
    :param hello_packet: the received hello packet
    :param cur_time: the moment when the packet is received
    :return: none
- `remove_neighbor(self, drone_id)` (line 41)
- `is_neighbor(self, drone_id)` (line 45)
    - Calls: self.get_updated_time, self.neighbor_table.keys
- `purge(self)` (line 53)
    - Calls: list, self.get_updated_time, self.is_empty, self.remove_neighbor
- `clear(self)` (line 64)
    - Calls: self.neighbor_table.clear
- `get_min_q_value(self, dst_drone_id)` (line 68)
    - Calls: self.neighbor_table.keys, self.purge
- `best_neighbor(self, my_drone, dst_drone)` (line 79)

    Choose the best next hop according to the Q-table
    :param my_drone: the drone that installed the GPSR
    :param dst_drone: the destination of the data packet
    :return: none
    - Calls: candidate_of_min_q_list.append, len, list, math.pow, self.neighbor_table.keys, self.purge, self.rng_routing.choice, self.rng_routing.random

## File: routing\qfanet\qfanet.py

### Class `QFanet`  (line 21)
**Docstring:**

```
Main procedure of Q-FANET protocol
References:
    [1] da Costa, Luis Antonio LF, Rafael Kunst, and Edison Pignaton de Freitas.
    "Q-FANET: Improved Q-learning based routing protocol for FANETs." Computer Networks 198 (2021): 108379
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 29)
    - Calls: QFanetTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.simulator.env.process
- `broadcast_hello_packet(self)` (line 51)

    Generate Hello packet
    - Calls: QFanetHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 72)

    Broadcast hello packet periodically
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 79)

    Select the next hop according to the routing protocol

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        Next hop drone
    - Calls: packet.intermediate_drones.append, self.table.best_neighbor, self.table.purge
- `packet_reception(self, packet, src_drone_id)` (line 103)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: QFanetAckPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, logger.info, receive, self.cal_p2p_sinr, self.my_drone.mac_protocol.phy.unicast, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.simulator.metrics.mac_delay.append, self.table.add_neighbor, self.table.calculate_eta, self.table.update_q_value, self.table.void_area_judgment, str
- `check_waiting_list(self)` (line 205)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.next_hop_selection, self.simulator.env.timeout
- `cal_p2p_sinr(self, data_packet, previous_drone_id)` (line 222)

    Calculate point to point sinr
    - Calls: self.get_current_transmitting_nodes, sinr_calculator
- `penalize(self, packet)` (line 230)
    - Calls: self.table.update_q_value
- `get_current_transmitting_nodes(self)` (line 241)

    Get all the nodes that are currently transmitting
    - Calls: has_intersection, list, transmitting_nodes.append, tuple

## File: routing\qfanet\qfanet_packet.py

### Class `QFanetHelloPacket`  (line 13)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, simulator, channel_id)` (line 15)
    - Calls: __init__, super

### Class `QFanetAckPacket`  (line 30)
**Methods:**

- `__init__(self, src_drone, dst_drone, ack_packet_id, ack_packet_length, acked_packet, void_area_flag, reward, sinr_eta, simulator, channel_id, creation_time)` (line 31)
    - Calls: __init__, super

## File: routing\qfanet\qfanet_table.py

### Class `QFanetTable`  (line 20)
**Docstring:**

```
Q-FANET tables
```
**Methods:**

- `__init__(self, env, my_drone, rng_routing)` (line 32)
    - Calls: defaultdict, maximum_communication_range, np.full
- `is_neighbor(self, drone_id)` (line 45)

    Check if the drone is a neighbor
    - Calls: euclidean_distance_3d
- `add_neighbor(self, hello_packet, cur_time, cur_sinr)` (line 58)

    Add neighbor to the table
- `purge(self)` (line 74)

    Remove expired neighbor entry
    - Calls: list, self.is_neighbor, self.neighbor_table.keys
- `calculate_eta(self, sinr)` (line 80)

    Transform SINR to eta value
- `calculate_velocity_constraint(self, neighbor_id, dst_drone)` (line 93)

    Calculate Velocity
    - Calls: euclidean_distance_3d, self.is_neighbor
- `void_area_judgment(self, dst_drone)` (line 104)

    Routing hole judgment
    - Calls: euclidean_distance_3d, self.is_neighbor, self.purge
- `get_candidate_neighbors(self, dst_drone, packet)` (line 119)

    Obtain the candidates neighbors
    - Calls: candidates.append, self.calculate_velocity_constraint, self.purge, sub_candidates.append, util_function.euclidean_distance_3d
- `best_neighbor(self, packet, dst_drone, epsilon)` (line 138)
    - Calls: len, list, max, self.get_candidate_neighbors, self.neighbor_table.keys, self.purge, self.rng_routing.choice, self.rng_routing.random
- `update_q_value(self, next_hop_id, dst_id, reward, sinr_eta)` (line 159)

    Q-Noise+ update
    - Calls: append, get, len, lookback_rewards.insert, range, self.is_neighbor, self.rng_routing.random, sum, zip

## File: routing\qgeo\qgeo.py

### Class `QGeo`  (line 14)
**Docstring:**

```
Main procedure of QGeo (without consideration of link error and location error)

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the GPSR
    rng_routing: a Random class based on which we can call the function that generates the random number
    hello_interval: time interval of sending hello packet
    check_interval: time interval of checking the waiting list
    learning_rate: hyperparameter in Q-learning
    r_max: if the next hop is the destination, the maximum reward "r_max" will be given
    r_min: if void area is reached or no ACK is received, the minimum reward "r_min" will be given
    table: including neighbor table and Q-table

References:
    [1] W. Jung, J. Yim and Y. Ko, "QGeo: Q-learning-based Geographic Ad Hoc Routing Protocol for Unmanned Robotic
        Networks," in IEEE Communications Letters, vol. 21, no. 10, pp. 2258-2261, 2017.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2025/2/22
Updated at: 2025/4/15
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 38)
    - Calls: QGeoTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.simulator.env.process
- `broadcast_hello_packet(self, my_drone)` (line 51)
    - Calls: QGeoHelloPacket, logger.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 71)
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 77)

    Select the next hop according to the routing protocol

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        Next hop drone
    - Calls: packet.intermediate_drones.append, self.table.best_neighbor, self.table.purge
- `packet_reception(self, packet, src_drone_id)` (line 107)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: QGeoAckPacket, VfPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, logger.info, maximum_communication_range, receive, self.my_drone.mac_protocol.phy.unicast, self.my_drone.motion_controller.neighbor_table.add_neighbor, self.my_drone.remove_from_queue, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.table.add_neighbor, self.table.get_max_q_value, self.table.void_area_judgment, self.update_q_table, str, util_function.euclidean_distance_3d
- `update_q_table(self, packet, next_hop_id, next_hop_coords, next_hop_velocity)` (line 251)
    - Calls: math.ceil, maximum_communication_range, self.simulator.metrics.mac_delay.append, util_function.euclidean_distance_3d
- `check_waiting_list(self)` (line 282)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.next_hop_selection, self.simulator.env.timeout
- `penalize(self, packet)` (line 299)

## File: routing\qgeo\qgeo_packet.py

### Class `QGeoHelloPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, simulator, channel_id)` (line 5)
    - Calls: __init__, super

### Class `QGeoAckPacket`  (line 19)
**Methods:**

- `__init__(self, src_drone, dst_drone, ack_packet_id, ack_packet_length, acked_packet, void_area_flag, reward, max_q, simulator, channel_id, creation_time)` (line 20)
    - Calls: __init__, super

## File: routing\qgeo\qgeo_table.py

### Class `QGeoTable`  (line 9)
**Methods:**

- `__init__(self, env, my_drone, rng_routing)` (line 10)
    - Calls: defaultdict, np.zeros
- `is_empty(self)` (line 21)
    - Calls: bool
- `get_updated_time(self, drone_id)` (line 25)
    - Calls: RuntimeError, self.neighbor_table.keys
- `add_neighbor(self, hello_packet, cur_time)` (line 31)

    Update the neighbor table according to the hello packet
    :param hello_packet: the received hello packet
    :param cur_time: the moment when the packet is received
    :return: none
- `remove_neighbor(self, drone_id)` (line 49)
- `is_neighbor(self, drone_id)` (line 53)
    - Calls: self.get_updated_time, self.neighbor_table.keys
- `purge(self)` (line 61)
    - Calls: list, self.get_updated_time, self.is_empty, self.remove_neighbor
- `clear(self)` (line 72)
    - Calls: self.neighbor_table.clear
- `void_area_judgment(self, dst_drone)` (line 76)
    - Calls: euclidean_distance_3d, self.neighbor_table.keys
- `get_max_q_value(self, dst_drone_id)` (line 89)
    - Calls: self.neighbor_table.keys, self.purge
- `best_neighbor(self, my_drone, dst_drone)` (line 100)

    Choose the best next hop according to the Q-table
    :param my_drone: the drone that installed the GPSR
    :param dst_drone: the destination of the data packet
    :return: none
    - Calls: candidate_of_max_q_list.append, len, list, math.pow, self.is_empty, self.neighbor_table.keys, self.purge, self.rng_routing.choice, self.rng_routing.random

## File: routing\qmr\history_packets_recorder.py

### Class `HistoryPacketsRecorder`  (line 4)
**Methods:**

- `__init__(self, n_drones)` (line 5)
    - Calls: self.init_recorder_for_all_ids
- `init_recorder_for_all_ids(self)` (line 17)
    - Calls: range
- `add_sent_data_packet(self, data_packet)` (line 23)

    Add a record when a drone sends a data packet
    - Calls: append
- `add_sent_hello_packet(self, hello_packet)` (line 32)

    Add a record when a drone broadcasts a hello packet
    - Calls: self.history_sent_hello_packets.append
- `add_received_ack_packet(self, ack_packet)` (line 37)
    - Calls: append
- `add_received_hello_packet(self, hello_packet)` (line 44)

    Add a record when a drone receives a hello packet from its neighbor
    - Calls: append
- `get_active_sent_data_packet_count(self, next_hop_id, cur_time)` (line 53)
    - Calls: clear_old_packet, count_without_newer_packet
- `get_sent_hello_packet_between_count(self, begin_time, end_time)` (line 61)
- `get_active_received_ack_packet_count(self, source_id, cur_time)` (line 72)
    - Calls: clear_old_packet, count_without_newer_packet
- `get_all_active_received_hello_packet_count(self, cur_time)` (line 79)
    - Calls: clear_old_packet, count_and_found_most_early_time, self.history_received_hello_packets.items
- `clear_received_packets_for_neighbor(self, neighbor_id)` (line 88)

### Function `clear_old_packet(packet_time_tuple_list, begin_time)`  (line 92)
**Calls:** len, packet_time_tuple_list.pop

### Function `count_without_newer_packet(packet_time_tuple_list, begin_time, cur_time)`  (line 101)

### Function `count_and_found_most_early_time(packet_time_tuple_list, begin_time, cur_time)`  (line 112)

## File: routing\qmr\qmr.py

### Class `QMR`  (line 12)
**Docstring:**

```
Main procedure of QMR: Q-learning based Multi-objective optimization routing protocol

References:
    [1] J. Liu, Q. Wang, C. He, K. Jaffrès-Runser, Y. Xu, Z. Li and Y. Xu, "QMR:Q-learning based Multi-objective
    Optimization Routing protocol for Flying Ad Hoc Networks," Computer Communications, vol. 150, pp. 304-316, 2020.

Created at: 2025/2/9
Updated at: 2025/7/2
```
**Methods:**

- `__init__(self, simulator, my_drone)` (line 24)
    - Calls: HistoryPacketsRecorder, QMRTable, random.Random, self.broadcast_hello_packet_periodically, self.check_waiting_list, self.simulator.env.process, self.update_discounted_factor, self.update_eps
- `broadcast_hello_packet(self, my_drone)` (line 42)

    Generate one hello packet
    - Calls: QMRHelloPacket, logger.info, self.history_packet_recorder.add_sent_hello_packet, self.history_packet_recorder.get_all_active_received_hello_packet_count, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put
- `broadcast_hello_packet_periodically(self)` (line 72)

    Broadcast hello packet periodically
    - Calls: self.broadcast_hello_packet, self.rng_routing.randint, self.simulator.env.timeout
- `next_hop_selection(self, packet)` (line 80)

    Select the next hop according to the routing protocol

    Parameters:
        packet: the data packet that needs to be sent

    Returns:
        Next hop drone
    - Calls: packet.intermediate_drones.append, self.history_packet_recorder.add_sent_data_packet, self.table.make_route_decision, self.table.purge
- `update_discounted_factor(self)` (line 112)
    - Calls: self.simulator.env.timeout, self.table.update_discounted_factor
- `packet_reception(self, packet, src_drone_id)` (line 117)

    Packet reception at network layer

    since different routing protocols have their own corresponding packets, it is necessary to add this packet
    reception function in the network layer

    Parameters:
        packet: the received packet
        src_drone_id: previous hop
    - Calls: QMRAckPacket, ack_packet.increase_ttl, copy.copy, interrupt, isinstance, logger.info, receive, self.history_packet_recorder.add_received_ack_packet, self.history_packet_recorder.add_received_hello_packet, self.my_drone.mac_protocol.phy.unicast, self.my_drone.transmitting_queue.put, self.my_drone.transmitting_queue.qsize, self.simulator.env.timeout, self.simulator.metrics.calculate_metrics, self.simulator.metrics.mac_delay.append, self.table.add_mac_delay, self.table.check_local_minimum, self.table.get_max_q, self.table.update_neighbor, self.update
- `update(self, packet, next_hop_id)` (line 205)
    - Calls: self.table.update_q_value
- `check_waiting_list(self)` (line 218)
    - Calls: self.my_drone.transmitting_queue.put, self.my_drone.waiting_list.remove, self.simulator.env.timeout, self.table.make_route_decision
- `penalty_for_ack_loss(self, packet)` (line 236)
    - Calls: self.table.get_last_max_q_value_of_neighbor, self.table.update_q_value
- `update_eps(self)` (line 245)
    - Calls: max, self.simulator.env.timeout
- `penalize(self, packet)` (line 250)

## File: routing\qmr\qmr_packet.py

### Class `QMRHelloPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, received_hello_packet_count, simulator, channel_id)` (line 5)
    - Calls: __init__, super

### Class `QMRAckPacket`  (line 21)
**Methods:**

- `__init__(self, src_drone, dst_drone, ack_packet_id, ack_packet_length, ack_packet, transmitting_start_time, queuing_delay, max_q, is_local_minimum, simulator, source_packet_backoff_start_time, channel_id, creation_time)` (line 22)
    - Calls: __init__, super

## File: routing\qmr\qmr_table.py

### Class `QMRTable`  (line 9)
**Methods:**

- `__init__(self, env, my_drone)` (line 10)
- `is_empty(self)` (line 40)

    Determine if the neighbor table is empty
    - Calls: bool
- `add_new_neighbor_entry(self, drone_id)` (line 45)

    Add a new entry in the neighbor table
- `update_neighbor(self, hello_packet, cur_time)` (line 67)

    Update neighbor entry according to the incoming hello packet
    - Calls: self.add_new_neighbor_entry, self.generate_lq
- `get_updated_time(self, drone_id)` (line 87)
    - Calls: RuntimeError, self.neighbor_table.keys
- `remove_neighbor(self, drone_id)` (line 93)

    Delete the specified entry
    - Calls: self.my_drone.routing_protocol.history_packet_recorder.clear_received_packets_for_neighbor
- `purge(self)` (line 98)

    Remove the expired entry in neighbor table
    - Calls: list, self.get_updated_time, self.is_empty, self.neighbor_table.keys, self.remove_neighbor
- `generate_lq(self, hello_packet, neighbor_id, received_hello_count)` (line 110)

    The link quality (lq) is calculated using the forward delivery ratios "df" and
    reverse delivery ratio "dr" of the link, where "df" represents the probability
    that a data packet successfully arrives at the recipient, and "df" represents
    the probability of sender successfully receiving ACK packets.

    Hello packet is used to measure "df" and "dr"

    Args:
        hello_packet: the incoming hello packet
        neighbor_id: the id of the drone which broadcasts the hello packet
        received_hello_count:

    Returns:
    - Calls: history_packet_recorder.get_active_received_ack_packet_count, history_packet_recorder.get_active_sent_data_packet_count, history_packet_recorder.get_sent_hello_packet_between_count, logger.info
- `compute_actual_velocity_3d(self, neighbor_id, cur_time, i_dist_to_dest, dst_coords)` (line 167)

    Calculate the actual velocity of the data packet from node i to its neighbor j

    Args:
        neighbor_id: the id of the neighbor drone
        cur_time: the current moment
        i_dist_to_dest: the distance between the real position of the node i at t2 and the destination
        dst_coords: the coordinates of the destination node

    Returns: actual velocity of the data packet
    - Calls: util_function.euclidean_distance_3d
- `add_mac_delay(self, mac_delay, cur_time, neighbor_id)` (line 208)

    When a mac delay is measured, it is added into the "mac_delay_recorder"
    For a drone i with m neighbors, it always maintains m sliding windows with length n,
    each window records the MAC delay of the last n data packets sent by node i to node j.

    Args:
        mac_delay:
        cur_time: the current moment
        neighbor_id:

    Returns:
    - Calls: append, iter, len, next, self.mac_delay_recorder.pop
- `add_queuing_delay(self, queuing_delay, cur_time)` (line 234)

    When a queuing delay is measured, it is added into the queuing_delay_recorder
    - Calls: len, self.queuing_delay_recorder.append, self.queuing_delay_recorder.pop
- `get_window_mean_mac_delay(self, neighbor_id)` (line 242)

    Update MAC delay using exponentially weighted moving average
    - Calls: self.get_mean_delay
- `get_window_mean_queuing_delay(self)` (line 251)

    Update queuing delay using exponentially weighted moving average
    - Calls: self.get_mean_delay
- `get_mean_delay(self, delay_recorder)` (line 257)
    - Calls: len, np.mean
- `update_delay(self, neighbor_id, cur_time)` (line 268)
    - Calls: append, len, pop, self.get_window_mean_mac_delay, self.get_window_mean_queuing_delay
- `get_normalized_delay(self, neighbor_id)` (line 281)

    Used in adaptively adjusting the learning rate
    - Calls: abs, len, np.mean, np.std
- `get_reward(self, f, is_penalty, next_hop_id)` (line 303)
    - Calls: np.exp
- `get_max_q(self)` (line 314)
    - Calls: len, max, self.neighbor_table.keys
- `filter_space_of_exploration(self, packet, destination, cur_time)` (line 319)
    - Calls: candidate_neighbors.append, self.compute_actual_velocity_3d, self.neighbor_table.keys, sub_candidate_neighbors.append, util_function.euclidean_distance_3d
- `route_decision_qmr(self, packet, destination)` (line 365)
    - Calls: len, max, self.filter_space_of_exploration, self.neighbor_table.keys
- `make_route_decision(self, packet, destination, eps)` (line 387)
    - Calls: self.route_decision_e_greedy, self.route_decision_qmr
- `route_decision_e_greedy(self, eps)` (line 393)
    - Calls: len, list, logger.info, max, random.choice, random.random, self.neighbor_table.keys, self.purge
- `update_discounted_factor(self)` (line 411)
- `update_q_value(self, f, max_q, next_hop_id, is_penalty, dst_drone)` (line 417)
    - Calls: max, np.exp, self.get_normalized_delay, self.get_reward
- `check_local_minimum(self, destination)` (line 445)
    - Calls: self.neighbor_table.keys, util_function.euclidean_distance_3d

## File: simulator\metrics.py

### Class `Metrics`  (line 6)
**Docstring:**

```
Tools for statistics of network performance

1. Packet Delivery Ratio (PDR): is the ratio of number of packets received at the destinations to the number
   of packets sent from the sources
2. Average end-to-end (E2E) delay: is the time a packet takes to route from a source to its destination through
   the network. It is the time the data packet reaches the destination minus the time the data packet was generated
   in the source node
3. Routing Load: is calculated as the ratio between the numbers of control Packets transmitted
   to the number of packets actually received. NRL can reflect the average number of control packets required to
   successfully transmit a data packet and reflect the efficiency of the routing protocol
4. Throughput: it can be defined as a measure of how fast the data is sent from its source to its intended
   destination without loss. In our simulation, each time the destination receives a data packet, the throughput is
   calculated and finally averaged
5. Hop count: used to record the number of router output ports through which the packet should pass.

References:
    [1] Rani. N, Sharma. P, Sharma. P., "Performance Comparison of Various Routing Protocols in Different Mobility
        Models," in arXiv preprint arXiv:1209.5507, 2012.
    [2] Gulati M K, Kumar K. "Performance Comparison of Mobile Ad Hoc Network Routing Protocols," International
        Journal of Computer Networks & Communications. vol. 6, no. 2, pp. 127, 2014.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/4/22
```
**Methods:**

- `__init__(self, simulator)` (line 34)
    - Calls: defaultdict, set
- `calculate_metrics(self, received_packet)` (line 56)

    Calculate the corresponding metrics when the destination receives a data packet successfully
    - Calls: received_packet.get_current_ttl, self.datapacket_arrived.add
- `print_metrics(self)` (line 65)
    - Calls: len, list, np.mean, print, self.deliver_time_dict.values, self.hop_cnt_dict.values, self.throughput_dict.values

## File: simulator\simulator.py

### Class `Simulator`  (line 16)
**Docstring:**

```
Description: simulation environment

Attributes:
    env: simpy environment
    total_simulation_time: discrete time steps, in nanosecond
    n_drones: number of the drones
    channel_states: a dictionary, used to describe the channel usage
    channel: wireless channel
    metrics: Metrics class, used to record the network performance
    drones: a list, contains all drone instances

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/1/11
Updated at: 2025/7/8
```
**Methods:**

- `__init__(self, seed, env, channel_states, n_drones, total_simulation_time)` (line 34)
    - Calls: Channel, Drone, Metrics, print, random.randint, range, scatter_plot, self.channel.create_inbox_for_receiver, self.drones.append, self.env.process, self.show_performance, self.show_time, start_coords.get_random_start_point_3d
- `show_time(self)` (line 81)
    - Calls: print, self.env.timeout
- `show_performance(self)` (line 88)
    - Calls: scatter_plot, self.env.timeout, self.metrics.print_metrics

## File: tools\generate_repo_doc.py

### Class `DefInfo`  (line 26)
**Methods:**

- `__init__(self, name, typ, lineno, signature, docstring, filepath)` (line 27)
    - Calls: set

### Function `iter_py_files(root)`  (line 38)
**Calls:** any, root.rglob

### Function `get_signature(node)`  (line 45)
**Calls:** args.append, join

### Function `collect_defs(filepath)`  (line 57)
**Calls:** DefInfo, Visitor, ast.get_docstring, ast.parse, ast.walk, defs.append, di.calls.add, filepath.read_text, get_signature, isinstance, join, parts.append, reversed, self.current_class.methods.append, self.visit, visit

### Function `build_repo_index(root)`  (line 116)
**Calls:** collect_defs, f.relative_to, iter_py_files, print, str

### Function `generate_markdown(index, out_md)`  (line 128)
**Calls:** index.items, join, lines.append, out_md.write_text, print, sorted, strip, textwrap.dedent, textwrap.indent

### Function `md_to_docx(md_path, docx_path)`  (line 173)
**Calls:** Document, block.split, block.startswith, doc.add_heading, doc.add_paragraph, doc.save, header.count, header.lstrip, join, md_path.read_text, min, p.add_run, print, rest.strip, str, strip, subprocess.check_call, text.split

### Function `main()`  (line 211)
**Calls:** build_repo_index, generate_markdown, md_to_docx, print

## File: topology\virtual_force\vf_motion_control.py

### Class `VfMotionController`  (line 19)
**Docstring:**

```
Main procedure of motion controller

Attributes:
    simulator: the simulation platform that contains everything
    my_drone: the drone that installed the GPSR
    neighbor_table: used to record the neighbor's information
    position_update_interval: in microsecond, determine how often the drone updates its position
    max_step: in meter, the maximum moving distance in each round
    pause_time: in microsecond, time spent waiting for ACK
    next_position: the position to which the drone needs to move in each round

References:
    [1] Liu. H, et al.,"Simple Movement Control Algorithm for Bi-connectivity in Robotic Sensor Networks,"
        IEEE Journal on Selected Areas in Communications, vol. 28, no. 7, pp. 994-1005, 2010.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/5/20
Updated at: 2025/3/28
```
**Methods:**

- `__init__(self, drone)` (line 41)
    - Calls: VfNeighborTable, self.get_next_position, self.initialization, self.motion_control, self.my_drone.simulator.env.process, self.show_trajectory, self.simulator.env.process
- `get_next_position(self)` (line 66)
    - Calls: list, math.atan, math.sqrt, np.array, self.neighbor_table.attractive_force, self.neighbor_table.purge, self.neighbor_table.repulsive_force, sum, zip
- `initialization(self)` (line 84)
    - Calls: VfPacket, logging.info, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put, self.simulator.env.timeout
- `motion_control(self, drone)` (line 104)
    - Calls: VfPacket, env.timeout, euclidean_distance_3d, self.get_next_position, self.my_drone.channel_assigner.channel_assign, self.my_drone.transmitting_queue.put, self.trajectory.append, type
- `show_trajectory(self)` (line 168)
    - Calls: ax.plot, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, len, np.array, plt.axes, plt.figure, plt.show, range, self.my_drone.simulator.env.timeout, x.append, y.append, z.append

## File: topology\virtual_force\vf_neighbor_table.py

### Class `VfNeighborTable`  (line 9)
**Docstring:**

```
Neighbor table of motion controller

Neighbors in this algorithm is mainly used to calculate repulsive force

Attributes:
    env: simpy environment
    my_drone: the drone that installed the GPSR
    neighbor_table: a dictionary, used to store the neighbor's information
    entry_life_time: lifetime of each item in the neighbor table
    k: The elastic coefficient of a spring
    desired_distance: when the distance between two nodes is below 'desired_distance', a repulsive force
                      will be generated

References:
    [1] Liu. H, et al.,"Simple Movement Control Algorithm for Bi-connectivity in Robotic Sensor Networks,"
        IEEE Journal on Selected Areas in Communications, vol. 28, no. 7, pp. 994-1005, 2010.

Author: Zihao Zhou, eezihaozhou@gmail.com
Created at: 2024/5/20
Updated at: 2025/3/28
```
**Methods:**

- `__init__(self, env, my_drone)` (line 33)
    - Calls: defaultdict
- `add_neighbor(self, packet, cur_time)` (line 41)

    Update the neighbor table according to the hello packet
    :param packet: the received hello packet or ack packet
    :param cur_time: the moment when the packet is received
    :return: none
- `attractive_force(self)` (line 53)

    Calculate the attractive force applied by center point

    Note from ref [1]: the attractive force is introduced between every drone and the central point of the region,
    so that it leads the drones to move towards the centre of the region. With the attractive force, the drones
    can maintain connectivity among themselves.

    :return: attractive force in three dimensions
    - Calls: euclidean_distance_3d, math.sqrt, sum, zip
- `repulsive_force(self)` (line 79)

    Calculate the repulsive force applied by neighbors

    Note from ref [1]: the repulsive force is introduced between every pair of drones if their distance is less
    than a certain value. With repulsive force, the drones can increase the coverage.

    :return: repulsive force in three dimensions
    - Calls: euclidean_distance_3d, list, math.sqrt, np.array, self.neighbor_table.keys, sum, zip
- `get_updated_time(self, drone_id)` (line 112)
    - Calls: RuntimeError, self.neighbor_table.keys
- `remove_neighbor(self, drone_id)` (line 119)
- `purge(self)` (line 123)
    - Calls: bool, list, self.get_updated_time, self.remove_neighbor

## File: topology\virtual_force\vf_packet.py

### Class `VfPacket`  (line 4)
**Methods:**

- `__init__(self, src_drone, creation_time, id_hello_packet, hello_packet_length, simulator, channel_id)` (line 5)
    - Calls: __init__, super

## File: utils\ieee_802_11.py

### Class `IeeeStandard`  (line 1)
**Methods:**

- `__init__(self)` (line 2)

    Several notes about IEEE 802.11a:

    - The relationship between different bit rates and SNR threshold:
    |--------------|-------------------|-----------------|
    |   Bit rate   |  Modulation mode  |  SNR threshold  |
    |   6 Mbps     |      BPSK         |      4 dB       |
    |   9 Mbps     |      BPSK         |      5.5 dB     |
    |   12 Mbps    |      QPSK         |      7 dB       |
    |   18 Mbps    |      QPSK         |      8.5 dB     |
    |   24 Mbps    |      16-QAM       |      12 dB      |
    |   36 Mbps    |      16-QAM       |      16 dB      |
    |   48 Mbps    |      64-QAM       |      19.5 dB    |
    |   54 Mbps    |      64-QAM       |      21 dB      |

## File: utils\util_function.py

### Function `euclidean_distance_3d(p1, p2)`  (line 5)
**Docstring:**

```
Calculate the 3-D Euclidean distance between two nodes
:param p1: the first point
:param p2: the second point
:return: Euclidean distance between p1 and p2
```

### Function `euclidean_distance_2d(p1, p2)`  (line 17)
**Docstring:**

```
Calculate the 2-D Euclidean distance between two nodes
:param p1: the first point
:param p2: the second point
:return: 2-D Euclidean distance between p1 and p2
```

### Function `grid_map()`  (line 29)
**Docstring:**

```
Grid the map for path planning
```
**Calls:** int, np.zeros

### Function `has_intersection(interval1, interval2)`  (line 40)

### Function `check_channel_availability(channel_states, sender_drone, drones)`  (line 53)
**Docstring:**

```
Check if the channel is busy or idle
:param channel_states: a dictionary, indicates the use of the channel by different drones
:param sender_drone: the drone that is about to send packet
:param drones: a list, which contains all the drones in the simulation
:return: if the channel is busy, return "False", else, return "True"
```
**Calls:** channel_states.keys, euclidean_distance_3d, len

## File: visualization\static_drawing.py

### Function `scatter_plot(simulator)`  (line 9)
**Docstring:**

```
Draw a static scatter plot, includes communication edges (without obstacles)
```
**Calls:** Axes3D, ax.plot, ax.scatter, ax.set_box_aspect, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, euclidean_distance_3d, fig.add_axes, maximum_communication_range, plt.figure, plt.show

### Function `scatter_plot_with_obstacles(simulator, grid, path_list)`  (line 39)
**Calls:** ax.plot, ax.scatter, ax.set_box_aspect, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, fig.add_subplot, np.argwhere, np.array, plt.figure, plt.show

## File: visualization\visualizer.py

### Class `Arrow3D`  (line 14)
**Docstring:**

```
Class for drawing arrows in 3D view
```
**Methods:**

- `__init__(self, xs, ys, zs, *args, **kwargs)` (line 18)
    - Calls: FancyArrowPatch.__init__
- `do_3d_projection(self, renderer)` (line 22)
    - Calls: np.mean, proj3d.proj_transform, self.set_positions
- `draw(self, renderer)` (line 30)
    - Calls: FancyArrowPatch.draw

### Class `SimulationVisualizer`  (line 33)
**Docstring:**

```
Visualize UAV network simulation process, including movement trajectories and communication status
```
**Methods:**

- `__init__(self, simulator, output_dir, vis_frame_interval)` (line 38)

    Initialize visualizer

    Parameters:
        simulator: simulator instance
        output_dir: output directory
        vis_frame_interval: interval for visualization frames (microseconds)
    - Calls: np.linspace, os.makedirs, plt.cm.tab10, range, self._setup_communication_tracking
- `_setup_communication_tracking(self)` (line 81)

    Setup tracking for communication events
    - Calls: original_unicast_put, self.track_communication
- `track_drone_positions(self)` (line 112)

    Record current drone positions
    - Calls: append, enumerate, self.timestamps.append
- `track_communication(self, src_id, dst_id, packet_id, packet_type)` (line 123)

    Record communication event
    - Calls: self.comm_events.append
- `_draw_visualization_frame(self, fig, current_time)` (line 131)

    Draw visualization elements on two side-by-side axes

    Parameters:
        fig: matplotlib figure to draw on
        current_time: current simulation time (seconds)
    - Calls: Line2D, ax.grid, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, ax_ack.legend, ax_ack.set_title, ax_data.legend, ax_data.set_title, fig.add_subplot, fig.suptitle, int, self._draw_ack_links, self._draw_data_links, self._draw_drones, self._get_drone_positions, self._get_latest_comms
- `_get_latest_comms(self, comms, packet_type)` (line 188)

    Get only the latest communication for each src-dst pair

    Parameters:
        comms: List of communication events
        packet_type: Type of packet (DATA, ACK, HELLO)

    Returns:
        List of latest communication events for each src-dst pair
    - Calls: latest_comms_dict.values, list
- `create_animations(self)` (line 217)

    Create GIF animation of the simulation
    - Calls: Image.open, animation_frames.append, buf.close, buf.seek, enumerate, img.convert, img.copy, io.BytesIO, len, max, min, os.path.join, plt.close, plt.figure, plt.savefig, print, save, self._draw_visualization_frame, self.frame_times.append
- `run_visualization(self)` (line 294)

    Run visualization process
    - Calls: self.simulator.env.process, self.simulator.env.timeout, self.track_drone_positions, track_positions
- `finalize(self)` (line 310)

    Finalize visualization, generate frames and animations
    - Calls: print, self.create_animations, self.create_interactive_visualization
- `create_interactive_visualization(self)` (line 324)

    Create an interactive visualization with a slider for time navigation
    - Calls: Button, Line2D, Slider, TextBox, abs, ax.grid, ax.set_xlabel, ax.set_xlim, ax.set_ylabel, ax.set_ylim, ax.set_zlabel, ax.set_zlim, ax_ack.clear, ax_ack.legend, ax_ack.set_title, ax_data.clear, ax_data.legend, ax_data.set_title, fig.add_gridspec, fig.add_subplot, fig.canvas.draw_idle, fig.suptitle, float, goto_button.on_clicked, int, max, min, plt.axes, plt.figure, plt.show, plt.subplots_adjust, print, self._draw_ack_links, self._draw_data_links, self._draw_drones, self._get_drone_positions, self._get_latest_comms, self.frame_times.append, str, time_slider.on_changed, time_slider.set_val, time_text.set_val, update_plot
- `_get_drone_positions(self, current_time)` (line 470)

    Get drone positions at a specific time
    - Calls: abs, len, min, range
- `_draw_drones(self, ax, drone_positions)` (line 487)

    Draw drones on the given axis with embedded ID numbers
    - Calls: ax.scatter, ax.text, drone_positions.items, path_effects.withStroke
- `_draw_data_links(self, ax, data_comms, drone_positions)` (line 504)

    Draw DATA packet links on the given axis with smaller packet ID boxes
    - Calls: Arrow3D, ax.add_artist, ax.text, dict, range, str
- `_draw_ack_links(self, ax, ack_comms, drone_positions)` (line 532)

    Draw ACK packet links on the given axis with smaller packet ID boxes
    - Calls: ax.plot, ax.text, dict, range, str

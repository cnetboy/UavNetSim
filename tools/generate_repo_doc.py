#!/usr/bin/env python3
"""
Generate documentation for the repository:
- Scans .py files (excluding __pycache__)
- Extracts classes, functions, docstrings, signatures
- Builds a simple call map (function/method -> called names)
- Outputs Markdown to docs/UavNetSim_documentation.md
- Attempts to convert Markdown to .docx using python-docx (installs it if missing)

Run from repository root (where this script is created):
    python tools/generate_repo_doc.py
"""
import ast
import os
import sys
import textwrap
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
DOCS_DIR = ROOT / 'docs'
DOCS_DIR.mkdir(exist_ok=True)

EXCLUDE_DIRS = {'__pycache__', '.git', 'venv', '.venv'}


class DefInfo:
    def __init__(self, name, typ, lineno, signature, docstring, filepath):
        self.name = name
        self.typ = typ  # 'class' or 'function' or 'method'
        self.lineno = lineno
        self.signature = signature
        self.docstring = docstring or ''
        self.filepath = filepath
        self.calls = set()
        self.methods = []  # for classes: list of DefInfo for methods


def iter_py_files(root: Path):
    for p in root.rglob('*.py'):
        if any(part in EXCLUDE_DIRS for part in p.parts):
            continue
        yield p


def get_signature(node: ast.FunctionDef):
    args = []
    for a in node.args.args:
        args.append(a.arg)
    # varargs/kwargs
    if node.args.vararg:
        args.append('*' + node.args.vararg.arg)
    if node.args.kwarg:
        args.append('**' + node.args.kwarg.arg)
    return '(' + ', '.join(args) + ')'


def collect_defs(filepath: Path):
    source = filepath.read_text(encoding='utf-8')
    tree = ast.parse(source)

    defs = []
    # map of qualified name -> DefInfo
    def_map = {}

    class Visitor(ast.NodeVisitor):
        def __init__(self):
            self.current_class = None

        def visit_ClassDef(self, node: ast.ClassDef):
            doc = ast.get_docstring(node)
            di = DefInfo(node.name, 'class', node.lineno, '', doc, filepath)
            def_map[f'{node.name}@{filepath}'] = di
            defs.append(di)
            prev = self.current_class
            self.current_class = di
            # visit methods
            for child in node.body:
                if isinstance(child, ast.FunctionDef):
                    self.visit(child)
            self.current_class = prev

        def visit_FunctionDef(self, node: ast.FunctionDef):
            sig = get_signature(node)
            doc = ast.get_docstring(node)
            if self.current_class is None:
                di = DefInfo(node.name, 'function', node.lineno, sig, doc, filepath)
                def_map[f'{node.name}@{filepath}'] = di
                defs.append(di)
            else:
                di = DefInfo(node.name, 'method', node.lineno, sig, doc, filepath)
                self.current_class.methods.append(di)
                def_map[f'{self.current_class.name}.{node.name}@{filepath}'] = di
            # collect calls inside this function/method
            for n in ast.walk(node):
                if isinstance(n, ast.Call):
                    # function name can be Name or Attribute
                    func = n.func
                    if isinstance(func, ast.Name):
                        di.calls.add(func.id)
                    elif isinstance(func, ast.Attribute):
                        # get attribute chain as a.b.c
                        parts = []
                        cur = func
                        while isinstance(cur, ast.Attribute):
                            parts.append(cur.attr)
                            cur = cur.value
                        if isinstance(cur, ast.Name):
                            parts.append(cur.id)
                        di.calls.add('.'.join(reversed(parts)))
            # no need to descend further here (we already walked body)

    Visitor().visit(tree)
    return defs


def build_repo_index(root: Path):
    index = {}
    for f in iter_py_files(root):
        try:
            defs = collect_defs(f)
            if defs:
                index[str(f.relative_to(root))] = defs
        except Exception as e:
            print('Failed to parse', f, e, file=sys.stderr)
    return index


def generate_markdown(index, out_md: Path):
    lines = []
    lines.append('# UavNetSim Code Documentation\n')
    lines.append('Generated by tools/generate_repo_doc.py')
    lines.append('')

    for filepath, defs in sorted(index.items()):
        lines.append('## File: ' + filepath)
        lines.append('')
        for d in defs:
            if d.typ == 'class':
                lines.append(f"### Class `{d.name}`  (line {d.lineno})")
                if d.docstring:
                    lines.append('**Docstring:**')
                    lines.append('')
                    lines.append('```')
                    lines.append(textwrap.dedent(d.docstring).strip())
                    lines.append('```')
                if d.methods:
                    lines.append('**Methods:**')
                    lines.append('')
                    for m in d.methods:
                        lines.append(f"- `{m.name}{m.signature}` (line {m.lineno})")
                        if m.docstring:
                            s = textwrap.indent(textwrap.dedent(m.docstring).strip(), '    ')
                            lines.append('')
                            lines.append(s)
                        if m.calls:
                            lines.append('    - Calls: ' + ', '.join(sorted(m.calls)))
                    lines.append('')
            elif d.typ == 'function':
                lines.append(f"### Function `{d.name}{d.signature}`  (line {d.lineno})")
                if d.docstring:
                    lines.append('**Docstring:**')
                    lines.append('')
                    lines.append('```')
                    lines.append(textwrap.dedent(d.docstring).strip())
                    lines.append('```')
                if d.calls:
                    lines.append('**Calls:** ' + ', '.join(sorted(d.calls)))
                lines.append('')
    out_md.write_text('\n'.join(lines), encoding='utf-8')
    print('Wrote', out_md)


def md_to_docx(md_path: Path, docx_path: Path):
    try:
        from docx import Document
    except Exception:
        print('python-docx not installed; trying to install...')
        import subprocess
        subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'python-docx'])
        from docx import Document

    text = md_path.read_text(encoding='utf-8')
    doc = Document()
    for block in text.split('\n\n'):
        # simple handling: treat code blocks and headings
        if block.startswith('#'):
            # heading
            header = block.split('\n', 1)[0]
            level = header.count('#')
            title = header.lstrip('#').strip()
            if level == 1:
                doc.add_heading(title, level=1)
            else:
                doc.add_heading(title, level=min(level, 4))
            # add rest if exists
            rest = block.split('\n', 1)[1] if '\n' in block else ''
            if rest.strip():
                doc.add_paragraph(rest)
        elif block.startswith('```'):
            # code block
            code = '\n'.join(block.split('\n')[1:-1])
            p = doc.add_paragraph()
            p.style = 'Intense Quote'
            p.add_run(code)
        else:
            doc.add_paragraph(block)
    doc.save(str(docx_path))
    print('Wrote', docx_path)


def main():
    print('Scanning repository at', ROOT)
    index = build_repo_index(ROOT)
    md_out = DOCS_DIR / 'UavNetSim_documentation.md'
    docx_out = DOCS_DIR / 'UavNetSim_documentation.docx'
    generate_markdown(index, md_out)
    try:
        md_to_docx(md_out, docx_out)
    except Exception as e:
        print('Failed to produce docx:', e)
        print('Markdown kept at', md_out)


if __name__ == '__main__':
    main()
